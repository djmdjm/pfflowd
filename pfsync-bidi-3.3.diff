WARNING: this diff is untested with OpenBSD 3.3. Don't go asking for support
on OpenBSD mailing lists if you apply this. Don't bug me for support either.

djm@mindrot.org


Index: sbin/pfctl/pf_print_state.c
===================================================================
RCS file: /cvs/src/sbin/pfctl/pf_print_state.c,v
retrieving revision 1.21
diff -u -r1.21 pf_print_state.c
--- sbin/pfctl/pf_print_state.c	21 Jan 2003 22:23:49 -0000	1.21
+++ sbin/pfctl/pf_print_state.c	11 Feb 2003 12:03:07 -0000
@@ -233,7 +233,8 @@
  		min = s->expire % 60;
  		s->expire /= 60;
  		printf(", expires in %.2u:%.2u:%.2u", s->expire, min, sec);
-		printf(", %u pkts, %u bytes", s->packets, s->bytes);
+		printf(", %u:%u pkts, %u:%u bytes",
+		    s->packets[0], s->packets[1], s->bytes[0], s->bytes[1]);
  		if (s->rule.nr != -1)
  			printf(", rule %u", s->rule.nr);
  		printf("\n");
Index: sys/net/if_pfsync.c
===================================================================
RCS file: /cvs/src/sys/net/if_pfsync.c,v
retrieving revision 1.4
diff -u -r1.4 if_pfsync.c
--- sys/net/if_pfsync.c	23 Dec 2002 18:53:59 -0000	1.4
+++ sys/net/if_pfsync.c	11 Feb 2003 12:03:14 -0000
@@ -284,8 +284,10 @@
  		sp->expire = htonl(0);
  	else
  		sp->expire = htonl(st->expire - secs);
-	sp->packets = htonl(st->packets);
-	sp->bytes = htonl(st->bytes);
+	sp->packets[0] = htonl(st->packets[0]);
+	sp->packets[1] = htonl(st->packets[1]);
+	sp->bytes[0] = htonl(st->bytes[0]);
+	sp->bytes[1] = htonl(st->bytes[1]);
  	if (r == NULL)
  		sp->rule.nr = htonl(-1);
  	else
Index: sys/net/pf.c
===================================================================
RCS file: /cvs/src/sys/net/pf.c,v
retrieving revision 1.316
diff -u -r1.316 pf.c
--- sys/net/pf.c	5 Feb 2003 13:07:20 -0000	1.316
+++ sys/net/pf.c	11 Feb 2003 12:03:16 -0000
@@ -2101,8 +2101,8 @@
  		s->dst.state = TCPS_CLOSED;
  		s->creation = time.tv_sec;
  		s->expire = s->creation + TIMEOUT(*rm, PFTM_TCP_FIRST_PACKET);
-		s->packets = 1;
-		s->bytes = pd->tot_len;
+		s->packets[0] = 1;
+		s->bytes[0] = pd->tot_len;
  		if (pf_insert_state(s)) {
  			REASON_SET(&reason, PFRES_MEMORY);
  			pool_put(&pf_state_pl, s);
@@ -2320,8 +2320,8 @@
  		s->dst.state = PFUDPS_NO_TRAFFIC;
  		s->creation = time.tv_sec;
  		s->expire = s->creation + TIMEOUT(*rm, PFTM_UDP_FIRST_PACKET);
-		s->packets = 1;
-		s->bytes = pd->tot_len;
+		s->packets[0] = 1;
+		s->bytes[0] = pd->tot_len;
  		if (pf_insert_state(s)) {
  			REASON_SET(&reason, PFRES_MEMORY);
  			pool_put(&pf_state_pl, s);
@@ -2553,8 +2553,8 @@
  		s->dst.state = 0;
  		s->creation = time.tv_sec;
  		s->expire = s->creation + TIMEOUT(*rm, PFTM_ICMP_FIRST_PACKET);
-		s->packets = 1;
-		s->bytes = pd->tot_len;
+		s->packets[0] = 1;
+		s->bytes[0] = pd->tot_len;
  		if (pf_insert_state(s)) {
  			REASON_SET(&reason, PFRES_MEMORY);
  			pool_put(&pf_state_pl, s);
@@ -2737,8 +2737,8 @@
  		s->dst.state = PFOTHERS_NO_TRAFFIC;
  		s->creation = time.tv_sec;
  		s->expire = s->creation + TIMEOUT(*rm, PFTM_OTHER_FIRST_PACKET);
-		s->packets = 1;
-		s->bytes = pd->tot_len;
+		s->packets[0] = 1;
+		s->bytes[0] = pd->tot_len;
  		if (pf_insert_state(s)) {
  			REASON_SET(&reason, PFRES_MEMORY);
  			if (*rm && (*rm)->log)
@@ -2830,7 +2830,7 @@
  	u_int16_t		 win = ntohs(th->th_win);
  	u_int32_t		 ack, end, seq;
  	u_int8_t		 sws, dws;
-	int			 ackskew;
+	int			 ackskew, dirndx;
  	struct pf_state_peer	*src, *dst;

  	key.af = pd->af;
@@ -2845,9 +2845,11 @@
  	if (direction == (*state)->direction) {
  		src = &(*state)->src;
  		dst = &(*state)->dst;
+		dirndx = 0;
  	} else {
  		src = &(*state)->dst;
  		dst = &(*state)->src;
+		dirndx = 1;
  	}

  	if (src->wscale && dst->wscale && !(th->th_flags & TH_SYN)) {
@@ -2948,8 +2950,8 @@
  	    (ackskew <= MAXACKWINDOW)) {
  	    /* Acking not more than one window forward */

-		(*state)->packets++;
-		(*state)->bytes += pd->tot_len;
+		(*state)->packets[dirndx]++;
+		(*state)->bytes[dirndx] += pd->tot_len;

  		/* update max window */
  		if (src->max_win < win)
@@ -3034,12 +3036,13 @@
  			printf("pf: loose state match: ");
  			pf_print_state(*state);
  			pf_print_flags(th->th_flags);
-			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d\n",
-			    seq, ack, pd->p_len, ackskew, (*state)->packets);
+			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d\n",
+			    seq, ack, pd->p_len, ackskew,
+			    (*state)->packets[0], (*state)->packets[1]);
  		}

-		(*state)->packets++;
-		(*state)->bytes += pd->tot_len;
+		(*state)->packets[dirndx]++;
+		(*state)->bytes[dirndx] += pd->tot_len;

  		/* update max window */
  		if (src->max_win < win)
@@ -3073,13 +3076,14 @@
  			src->seqlo = 0;
  			src->seqhi = 1;
  			src->max_win = 1;
+			/* XXX - increment (*state)->packets */
  		} else if (pf_status.debug >= PF_DEBUG_MISC) {
  			printf("pf: BAD state: ");
  			pf_print_state(*state);
  			pf_print_flags(th->th_flags);
-			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d "
+			printf(" seq=%u ack=%u len=%u ackskew=%d pkts=%d:%d "
  			    "dir=%s,%s\n", seq, ack, pd->p_len, ackskew,
-			    ++(*state)->packets,
+			    (*state)->packets[0], (*state)->packets[1],
  			    direction == PF_IN ? "in" : "out",
  			    direction == (*state)->direction ? "fwd" : "rev");
  			printf("pf: State failure on: %c %c %c %c | %c %c\n",
@@ -3130,6 +3134,7 @@
  	struct pf_state_peer	*src, *dst;
  	struct pf_tree_node	 key;
  	struct udphdr		*uh = pd->hdr.udp;
+	int			dirndx;

  	key.af = pd->af;
  	key.proto = IPPROTO_UDP;
@@ -3143,13 +3148,15 @@
  	if (direction == (*state)->direction) {
  		src = &(*state)->src;
  		dst = &(*state)->dst;
+		dirndx = 0;
  	} else {
  		src = &(*state)->dst;
  		dst = &(*state)->src;
+		dirndx = 1;
  	}

-	(*state)->packets++;
-	(*state)->bytes += pd->tot_len;
+	(*state)->packets[dirndx]++;
+	(*state)->bytes[dirndx] += pd->tot_len;

  	/* update states */
  	if (src->state < PFUDPS_SINGLE)
@@ -3196,7 +3203,7 @@
  	struct pf_addr	*saddr = pd->src, *daddr = pd->dst;
  	u_int16_t	 icmpid, *icmpsum;
  	u_int8_t	 icmptype;
-	int		 state_icmp = 0;
+	int		 state_icmp = 0, dirndx;

  	switch (pd->proto) {
  #ifdef INET
@@ -3245,8 +3252,9 @@

  		STATE_LOOKUP();

-		(*state)->packets++;
-		(*state)->bytes += pd->tot_len;
+		dirndx = (direction == (*state)->direction) ? 0 : 1;
+		(*state)->packets[dirndx]++;
+		(*state)->bytes[dirndx] += pd->tot_len;
  		(*state)->expire = time.tv_sec +
  		    TIMEOUT((*state)->rule.ptr, PFTM_ICMP_ERROR_REPLY);

@@ -3665,6 +3673,7 @@
  {
  	struct pf_state_peer	*src, *dst;
  	struct pf_tree_node	 key;
+	int			dirndx;

  	key.af = pd->af;
  	key.proto = pd->proto;
@@ -3678,13 +3687,15 @@
  	if (direction == (*state)->direction) {
  		src = &(*state)->src;
  		dst = &(*state)->dst;
+		dirndx = 0;
  	} else {
  		src = &(*state)->dst;
  		dst = &(*state)->src;
+		dirndx = 1;
  	}

-	(*state)->packets++;
-	(*state)->bytes += pd->tot_len;
+	(*state)->packets[dirndx]++;
+	(*state)->bytes[dirndx] += pd->tot_len;

  	/* update states */
  	if (src->state < PFOTHERS_SINGLE)
Index: sys/net/pf_ioctl.c
===================================================================
RCS file: /cvs/src/sys/net/pf_ioctl.c,v
retrieving revision 1.49
diff -u -r1.49 pf_ioctl.c
--- sys/net/pf_ioctl.c	20 Jan 2003 20:29:52 -0000	1.49
+++ sys/net/pf_ioctl.c	11 Feb 2003 12:03:16 -0000
@@ -945,8 +945,8 @@
  		state->rt_ifp = NULL;
  		state->creation = time.tv_sec;
  		state->expire += state->creation;
-		state->packets = 0;
-		state->bytes = 0;
+		state->packets[0] = state->packets[1] = 0;
+		state->bytes[0] = state->bytes[1] = 0;
  		if (pf_insert_state(state)) {
  			pool_put(&pf_state_pl, state);
  			error = ENOMEM;
Index: sys/net/pfvar.h
===================================================================
RCS file: /cvs/src/sys/net/pfvar.h,v
retrieving revision 1.135
diff -u -r1.135 pfvar.h
--- sys/net/pfvar.h	8 Feb 2003 20:13:20 -0000	1.135
+++ sys/net/pfvar.h	11 Feb 2003 12:03:17 -0000
@@ -427,8 +427,8 @@
  	struct ifnet	*rt_ifp;
  	u_int32_t	 creation;
  	u_int32_t	 expire;
-	u_int32_t	 packets;
-	u_int32_t	 bytes;
+	u_int32_t	 packets[2];
+	u_int32_t	 bytes[2];
  	sa_family_t	 af;
  	u_int8_t	 proto;
  	u_int8_t	 direction;
Index: usr.sbin/tcpdump/print-pfsync.c
===================================================================
RCS file: /cvs/src/usr.sbin/tcpdump/print-pfsync.c,v
retrieving revision 1.7
diff -u -r1.7 print-pfsync.c
--- usr.sbin/tcpdump/print-pfsync.c	7 Jan 2003 00:28:08 -0000	1.7
+++ usr.sbin/tcpdump/print-pfsync.c	11 Feb 2003 12:03:33 -0000
@@ -114,8 +114,10 @@
  		bcopy(&s->rt_addr, &st.rt_addr, sizeof(st.rt_addr));
  		st.creation = ntohl(s->creation);
  		st.expire = ntohl(s->expire);
-		st.packets = ntohl(s->packets);
-		st.bytes = ntohl(s->bytes);
+		st.packets[0] = ntohl(s->packets[0]);
+		st.packets[1] = ntohl(s->packets[1]);
+		st.bytes[0] = ntohl(s->bytes[0]);
+		st.bytes[1] = ntohl(s->bytes[1]);
  		st.af = s->af;
  		st.proto = s->proto;
  		st.direction = s->direction;


